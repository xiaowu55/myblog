# 二叉树

## 二叉树理论基础

##### 二叉树的种类

1. 满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树
2. 完全二叉树：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。
3. 二叉搜索树：**二叉搜索树是一个有序树**。
	- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
	- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
	- 它的左、右子树也分别为二叉排序树
4. 平衡二叉搜索树：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

##### 二叉树的储存方式

1. 链式存储
2. 数组存储

##### 二叉树的遍历方式

1. 深度优先遍历：先往深走，遇到叶子节点再往回走。
	* 前序遍历：中左右
	* 中序遍历：左中右
	* 后序遍历：左右中
2. 广度优先遍历：一层一层的去遍历。
	* 层次遍历

## 二叉树的迭代遍历

题号

- [144.二叉树的前序遍历(opens new window)](https://leetcode.cn/problems/binary-tree-preorder-traversal/)
- [145.二叉树的后序遍历(opens new window)](https://leetcode.cn/problems/binary-tree-postorder-traversal/)
- [94.二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

### 思考

1. **每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！**
	1. **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
	2. **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
	3. **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

##### 方法一 

```ts
// 前序遍历
function preorderTraversal(node: TreeNode | null): number[] {
    function traverse(node: TreeNode | null, res: number[]): void {
        if (node === null) return;
        res.push(node.val);
        traverse(node.left, res);
        traverse(node.right, res);
    }
    const res: number[] = [];
    traverse(node, res);
    return res;
}

// 中序遍历
function inorderTraversal(node: TreeNode | null): number[] {
    function traverse(node: TreeNode | null, res: number[]): void {
        if (node === null) return;
        traverse(node.left, res);
        res.push(node.val);
        traverse(node.right, res);
    }
    const res: number[] = [];
    traverse(node, res);
    return res;
}

// 后序遍历
function postorderTraversal(node: TreeNode | null): number[] {
    function traverse(node: TreeNode | null, res: number[]): void {
        if (node === null) return;
        traverse(node.left, res);
        traverse(node.right, res);
        res.push(node.val);
    }
    const res: number[] = [];
    traverse(node, res);
    return res;
}
```

## 二叉树遍历迭代法

题号

- [144.二叉树的前序遍历(opens new window)](https://leetcode.cn/problems/binary-tree-preorder-traversal/)
- [145.二叉树的后序遍历(opens new window)](https://leetcode.cn/problems/binary-tree-postorder-traversal/)
- [94.二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

### 思考

1. 二叉树遍历用迭代法前序和后序是一组，中序不同

##### 方法一

```ts
// 前序遍历（迭代法）
// 入栈 右 -> 左
// 出栈 中 -> 左 -> 右
function preorderTraversal(root: TreeNode | null): number[] {
    if (root === null) return [];
    let res: number[] = [];
    let helperStack: TreeNode[] = [];
    let curNode: TreeNode = root;
    helperStack.push(curNode);
    while (helperStack.length > 0) {
        curNode = helperStack.pop()!;
        res.push(curNode.val);
        if (curNode.right !== null) helperStack.push(curNode.right);
        if (curNode.left !== null) helperStack.push(curNode.left);
    }
    return res;
};

// 中序遍历（迭代法）
// 入栈 左 -> 右
// 出栈 左 -> 中 -> 右

function inorderTraversal(root: TreeNode | null): number[] {
    let helperStack: TreeNode[] = [];
    let res: number[] = [];
    if (root === null) return res;
    let curNode: TreeNode | null = root;
    while (curNode !== null || helperStack.length > 0) {
        if (curNode !== null) {
            helperStack.push(curNode);
            curNode = curNode.left;
        } else {
            curNode = helperStack.pop()!;
            res.push(curNode.val);
            curNode = curNode.right;
        }
    }
    return res;
};

// 后序遍历（迭代法）
// 入栈 左 -> 右
// 出栈 中 -> 右 -> 左 结果翻转
function postorderTraversal(root: TreeNode | null): number[] {
    let helperStack: TreeNode[] = [];
    let res: number[] = [];
    let curNode: TreeNode;
    if (root === null) return res;
    helperStack.push(root);
    while (helperStack.length > 0) {
        curNode = helperStack.pop()!;
        res.push(curNode.val);
        if (curNode.left !== null) helperStack.push(curNode.left);
        if (curNode.right !== null) helperStack.push(curNode.right);
    }
    return res.reverse();
};
```

## 二叉树的层序遍历

题号[102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

### 思考

1. 思路是使用队列来遍历二叉树

##### 方法一 使用for

```ts
function levelOrder(root: TreeNode | null): number[][] {
    let queue = [],
        result = [],
        tmp:number[]=[]
    if(root===null)return []
    queue.push(root)
    let cur:TreeNode
    while(queue.length>0){
        for(let i=0,length=queue.length;i<length;i++){
            cur = queue.shift()!
            tmp.push(cur.val)
            if(cur.left!==null)queue.push(cur.left)
            if(cur.right!==null)queue.push(cur.right)
        }
        result.push(tmp)
        tmp =[]
    }
    return result
};
```



##### 方法二 使用while

```ts
function levelOrder(root: TreeNode | null): number[][] {
    let result = [],
        tmp = [],
        helpQueue = [],
        cur
    if(root===null)return []
    helpQueue.push(root) //入节点进队列
    while(helpQueue.length>0){  //二叉树的一层循环
        let size = helpQueue.length //设定一层遍历
        while(size--){
            cur = helpQueue.shift()
            tmp.push(cur.val)  //出一个节点
            if(cur.left!==null)helpQueue.push(cur.left) //判断是否为空
            if(cur.right!==null)helpQueue.push(cur.right)
        }
        result.push(tmp)
        tmp = []
    }
    return result
};
```

### 翻转二叉树

题号[226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

### 思考

1. 一开始使用层序遍历也做出来了
2. 使用递归，注意中序遍历的不同

##### 方法一 层序遍历

```ts
function invertTree(root: TreeNode | null): TreeNode | null {
    let queue = []
    if(root===null)return null
    queue.push(root)
    while(queue.length>0){
        for(let i=0,length=queue.length;i<length;i++){
            let cur = queue.shift(),
                tmp = cur.left
                cur.left = cur.right
                cur.right = tmp
                tmp = null

            if(cur.left!==null){
                queue.push(cur.left)
            }
            if(cur.right!==null){
                queue.push(cur.right)
            }
        }
    }
    return root
};
```

##### 方法二 递归

```ts
// 前序遍历
function invertTree(root: TreeNode | null): TreeNode | null {
    function reverse(cur){
        if(cur===null)return cur
        if(cur!==null)[cur.left,cur.right] = [cur.right,cur.left]
        reverse(cur.left)
        reverse(cur.right)
    }
    reverse(root)
    return root
};

// 后序遍历
function invertTree(root: TreeNode | null): TreeNode | null {
    function reverse(cur){
        if(cur===null)return cur
        reverse(cur.left)
        reverse(cur.right)
        if(cur!==null)[cur.left,cur.right] = [cur.right,cur.left]
    }
    reverse(root)
    return root
};

// 中序遍历
function invertTree(root: TreeNode | null): TreeNode | null {
    function reverse(cur){
        if(cur===null)return cur
        reverse(cur.left)
        if(cur!==null)[cur.left,cur.right] = [cur.right,cur.left]
        reverse(cur.left)  //要注意这边还是翻转left，中序遍历与前面两个不同的地方
    }
    reverse(root)
    return root
};
```

## 对称二叉树

题号[101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

### 思考

1. 要判断是否对称也就是能不能翻转
2. 因为要先比较下面的子节点一步一步往上退所以只能用后序

##### 方法一 后序递归

```ts
function isSymmetric(root: TreeNode | null): boolean {
    function compare(left,right){
        if(left===null&&right!==null)return false
        else if(left!==null&&right===null)return false
        else if(left===null&&right===null)return true
        else if(left.val!==right.val)return false
        else if(left!==null&&right!==null){
           let outside=  compare(left.left,right.right),
                inside = compare(left.right,right.left)
        return  outside&&inside
            
        }
    }
    return compare(root.left,root.right)

};
```

## 二叉树的最大深度

题号[104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

类似题[559. N 叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/)

##### 理解题意

1. 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数或者节点数
2. 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数或者节点数

### 思考

1. 最开始想到用迭代法
2. 递归法，因为要求的是深度所以从叶节点向根节点一直加，所以想到用后序遍历，因为要先达到根节点嘛
3. 递归还是不太熟练需要多练习

##### 方法一 迭代法

```ts
function maxDepth(root: TreeNode | null): number {
    let queue = [],
        deep=0,
        cur:TreeNode
    if(root===null)return 0
    queue.push(root)
    while(queue.length>0){
        for(let i=0,length=queue.length;i<length;i++){
            cur = queue.shift()!
            if(cur.left!==null)queue.push(cur.left)
            if(cur.right!==null)queue.push(cur.right)
        } //每一层结束后进行一次深度++
        deep++
    }
    return deep
};
```

##### 方法二 递归法

```ts
function maxDepth(root: TreeNode | null): number {
  //使用递归的方法 递归三部曲
    //1. 确定递归函数的参数和返回值
    function getdepth(node) {
    //2. 确定终止条件
        if(node === null) {
            return 0;
        }
    //3. 确定单层逻辑
        let leftdepth = getdepth(node.left);
        let rightdepth = getdepth(node.right);
        let depth = 1 + Math.max(leftdepth, rightdepth);
        return depth;
    }
    return getdepth(root);
};
```

## 二叉树的最小深度

题号[111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

### 思考

1. 层序遍历，当节点的left和right都不存在的时候返回这个深度



##### 方法一 层序遍历

```ts
function minDepth(root: TreeNode | null): number {
 let queue = [],
        deep=1,
        cur:TreeNode
    if(root===null)return 0
    queue.push(root)
    while(queue.length>0){
        for(let i=0,length=queue.length;i<length;i++){
            cur = queue.shift()!
            if(cur.left!==null)queue.push(cur.left)
            if(cur.right!==null)queue.push(cur.right)
            if(cur.left===null&&cur.right===null)return deep++
        }
        deep++
    }
};
```

##### 方法二 递归

```ts
function minDepth(root: TreeNode | null): number {
    if(!root) return 0;
    // 到叶子节点 返回 1
    if(!root.left && !root.right) return 1;
    // 只有右节点时 递归右节点
    if(!root.left) return 1 + minDepth(root.right);
    // 只有左节点时 递归左节点
    if(!root.right) return 1 + minDepth(root.left);
    return Math.min(minDepth(root.left), minDepth(root.right)) + 1;
};
```

## 完全二叉树的节点个数

题号[222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)

### 思考

1. 当成普通二叉树方法
	1. 层序遍历
	2. 递归遍历
2. 完全二叉树的特性
	1. 完全二叉树有一部分是满二叉树，而满二叉树有一个公式求节点数量 2^树深度 - 1 

### 思路

使用完全二叉树特性完成

1. 先搜索外侧（也就是左右两边）
2. 如果left===right就意味着是一个满二叉树，套公式返回
3. 不是再度细分进入下一层，重新完成这个逻辑

重点在于递归的理解以及每次进入下一层都要补一个一进去

递归思路

1. 确定参数以及函数返回值

	这里入参是节点，返回节点数量

2. 确定终止条件

	如果为空节点的话就返回0，如果是满二叉树的话就终止并且返回节点数目

3. 确定单层递归的逻辑

	和普通的思路一样



##### 方法一 普通二叉树 解法

```ts
//迭代法 
function countNodes(root: TreeNode | null): number {
    let queue = [],count=0
    if(root!==null)queue.push(root)
    while(queue.length>0){
        for(let i=0,length=queue.length;i<length;i++){
            let cur = queue.shift()
            count++
            if(cur.left!==null)queue.push(cur.left)
            if(cur.right!==null)queue.push(cur.right)
        }
    }
    return count
};
//递归法
function countNodes(root: TreeNode | null): number {
    function getCount(cur):number{
        if(cur===null)return 0
        let left = getCount(cur.left)
        let right = getCount(cur.right)
        if(cur!==null)return left+right+1
    }
    return getCount(root)
};
```

##### 方法二 完全二叉树特性解法

```ts
function countNodes(root: TreeNode | null): number {
    // 终止条件
    if(root===null)return 0
    let left = 0,right = 0,cur = root
    while(cur!==null){
        left++
        cur = cur.left
    }
    cur = root
    while(cur!==null){
        right++
        cur = cur.right
    }
    if(left===right){
        return (2<<left-1)-1
    }
    // 单层递归逻辑
    return countNodes(root.left)+countNodes(root.right)+1
};
```

## 平衡二叉树

题号[110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)

### 思考

1. 死活没想出来迭代法怎么做。。。
2. 有递归的思路，也知道是后序写法但是没写出来

### 思路

1. 要从叶节点一步一步判断到根节点，所以是用后序遍历
2. 高度相减不大于1就是平衡二叉树，返回的时候也是返回最大的那个高度
3. 有一个节点不满足就不是平衡二叉树，传递结果就可以了

##### 方法一 后序递归

```
function isBalanced(root: TreeNode | null): boolean {
    function get(cur):number{
        // 确定终止条件
        if(cur===null)return 0
        // 开始执行单层操作
        // 获得左高度
        let left = get(cur.left)
        if(left===-1)return -1 //失败的传递
        // 获得右高度
        let right = get(cur.right)
        if(right===-1)return -1

        // 计算左右子树之差判定该节点是否为平衡二叉树

        if(Math.abs(left-right)>1)return -1
        else return Math.max(left,right)+1//记住要加一因为要把这个节点的高度也加上去
    }
    return !(get(root)===-1)
};
```

## 二叉树的所有路径

题号[257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)

### 思考

1. 因为要一步一步往叶节点走，所以用前序来做
2. 视频里提到回溯，但是由于我们是直接传string是值传递所以不用考虑到这个

##### 方法一

```ts
function binaryTreePaths(root: TreeNode | null): string[] {
    let result = []
    //1. 确定递归函数 函数参数
    function get(cur,curPath){
     //2. 确定终止条件，到叶子节点就终止
        if(cur.left===null&& cur.right===null){
            curPath+=cur.val
            result.push(curPath)
            return
        }
        //3. 确定单层递归逻辑
        curPath += cur.val+'->' // 中
        if(cur.left!==null)get(cur.left,curPath) // 左
        if(cur.right!==null)get(cur.right,curPath)  // 右
    }
    get(root,'')
    return result
};
```

##### 方法二

```ts
function binaryTreePaths(root: TreeNode | null): string[] {
    function recur(cur:TreeNode,route:string,resArr:string[]):void{
        route+=String(cur.val)
        if(cur.left===null&&cur.right===null){
            resArr.push(route)
            return
        }
        if (cur.left !== null) recur(cur.left, route + '->', resArr);
        if (cur.right !== null) recur(cur.right, route + '->', resArr);
    }
    const resArr = []
    if(root===null)return resArr
    recur(root,'',resArr)
    return resArr
};
```

## 左叶子之和

题号[404. 左叶子之和](https://leetcode.cn/problems/sum-of-left-leaves/)

### 思考

1. 第一反应用迭代法
2. 后序递归

##### 方法一 迭代法

```ts

function sumOfLeftLeaves(root: TreeNode | null): number {
    let queue = [],sum =0
    if(root!==null)queue.push(root)
    while(queue.length>0){
        for(let i=0,length=queue.length;i<length;i++){
            let cur = queue.shift()
            if(cur.left!==null&&cur.left.left===null&&cur.left.right===null)sum+=cur.left.val
            if(cur.left!==null)queue.push(cur.left)
            if(cur.right!==null)queue.push(cur.right)
        }
    }
    return sum
};
```

##### 方法二 递归法

```ts
function sumOfLeftLeaves(root: TreeNode | null): number {
    if(root===null)return 0
    // if(root.left===null&&root.right===null)return 0
    let left = sumOfLeftLeaves(root.left)
    let right = sumOfLeftLeaves(root.right)
    if(root.left!==null&&root.left.left===null&&root.left.right===null){
        left = root.left.val
    }
    return left+right
};
```

