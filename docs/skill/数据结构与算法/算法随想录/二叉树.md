# 二叉树

## 二叉树理论基础

##### 二叉树的种类

1. 满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树
2. 完全二叉树：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。
3. 二叉搜索树：**二叉搜索树是一个有序树**。
	- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
	- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
	- 它的左、右子树也分别为二叉排序树
4. 平衡二叉搜索树：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

##### 二叉树的储存方式

1. 链式存储
2. 数组存储

##### 二叉树的遍历方式

1. 深度优先遍历：先往深走，遇到叶子节点再往回走。
	* 前序遍历：中左右
	* 中序遍历：左中右
	* 后序遍历：左右中
2. 广度优先遍历：一层一层的去遍历。
	* 层次遍历

## 二叉树的迭代遍历

题号

- [144.二叉树的前序遍历(opens new window)](https://leetcode.cn/problems/binary-tree-preorder-traversal/)
- [145.二叉树的后序遍历(opens new window)](https://leetcode.cn/problems/binary-tree-postorder-traversal/)
- [94.二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

### 思考

1. **每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！**
	1. **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
	2. **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
	3. **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

##### 方法一 

```ts
// 前序遍历
function preorderTraversal(node: TreeNode | null): number[] {
    function traverse(node: TreeNode | null, res: number[]): void {
        if (node === null) return;
        res.push(node.val);
        traverse(node.left, res);
        traverse(node.right, res);
    }
    const res: number[] = [];
    traverse(node, res);
    return res;
}

// 中序遍历
function inorderTraversal(node: TreeNode | null): number[] {
    function traverse(node: TreeNode | null, res: number[]): void {
        if (node === null) return;
        traverse(node.left, res);
        res.push(node.val);
        traverse(node.right, res);
    }
    const res: number[] = [];
    traverse(node, res);
    return res;
}

// 后序遍历
function postorderTraversal(node: TreeNode | null): number[] {
    function traverse(node: TreeNode | null, res: number[]): void {
        if (node === null) return;
        traverse(node.left, res);
        traverse(node.right, res);
        res.push(node.val);
    }
    const res: number[] = [];
    traverse(node, res);
    return res;
}
```

## 二叉树遍历迭代法

题号

- [144.二叉树的前序遍历(opens new window)](https://leetcode.cn/problems/binary-tree-preorder-traversal/)
- [145.二叉树的后序遍历(opens new window)](https://leetcode.cn/problems/binary-tree-postorder-traversal/)
- [94.二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

### 思考

1. 二叉树遍历用迭代法前序和后序是一组，中序不同

##### 方法一

```ts
// 前序遍历（迭代法）
// 入栈 右 -> 左
// 出栈 中 -> 左 -> 右
function preorderTraversal(root: TreeNode | null): number[] {
    if (root === null) return [];
    let res: number[] = [];
    let helperStack: TreeNode[] = [];
    let curNode: TreeNode = root;
    helperStack.push(curNode);
    while (helperStack.length > 0) {
        curNode = helperStack.pop()!;
        res.push(curNode.val);
        if (curNode.right !== null) helperStack.push(curNode.right);
        if (curNode.left !== null) helperStack.push(curNode.left);
    }
    return res;
};

// 中序遍历（迭代法）
// 入栈 左 -> 右
// 出栈 左 -> 中 -> 右

function inorderTraversal(root: TreeNode | null): number[] {
    let helperStack: TreeNode[] = [];
    let res: number[] = [];
    if (root === null) return res;
    let curNode: TreeNode | null = root;
    while (curNode !== null || helperStack.length > 0) {
        if (curNode !== null) {
            helperStack.push(curNode);
            curNode = curNode.left;
        } else {
            curNode = helperStack.pop()!;
            res.push(curNode.val);
            curNode = curNode.right;
        }
    }
    return res;
};

// 后序遍历（迭代法）
// 入栈 左 -> 右
// 出栈 中 -> 右 -> 左 结果翻转
function postorderTraversal(root: TreeNode | null): number[] {
    let helperStack: TreeNode[] = [];
    let res: number[] = [];
    let curNode: TreeNode;
    if (root === null) return res;
    helperStack.push(root);
    while (helperStack.length > 0) {
        curNode = helperStack.pop()!;
        res.push(curNode.val);
        if (curNode.left !== null) helperStack.push(curNode.left);
        if (curNode.right !== null) helperStack.push(curNode.right);
    }
    return res.reverse();
};
```

## 二叉树的层序遍历

题号[102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

### 思考

1. 思路是使用队列来遍历二叉树

##### 方法一 使用for

```ts
function levelOrder(root: TreeNode | null): number[][] {
    let queue = [],
        result = [],
        tmp:number[]=[]
    if(root===null)return []
    queue.push(root)
    let cur:TreeNode
    while(queue.length>0){
        for(let i=0,length=queue.length;i<length;i++){
            cur = queue.shift()!
            tmp.push(cur.val)
            if(cur.left!==null)queue.push(cur.left)
            if(cur.right!==null)queue.push(cur.right)
        }
        result.push(tmp)
        tmp =[]
    }
    return result
};
```



##### 方法二 使用while

```ts
function levelOrder(root: TreeNode | null): number[][] {
    let result = [],
        tmp = [],
        helpQueue = [],
        cur
    if(root===null)return []
    helpQueue.push(root) //入节点进队列
    while(helpQueue.length>0){  //二叉树的一层循环
        let size = helpQueue.length //设定一层遍历
        while(size--){
            cur = helpQueue.shift()
            tmp.push(cur.val)  //出一个节点
            if(cur.left!==null)helpQueue.push(cur.left) //判断是否为空
            if(cur.right!==null)helpQueue.push(cur.right)
        }
        result.push(tmp)
        tmp = []
    }
    return result
};
```

### 翻转二叉树

题号[226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

### 思考

1. 一开始使用层序遍历也做出来了
2. 使用递归，注意中序遍历的不同

##### 方法一 层序遍历

```ts
function invertTree(root: TreeNode | null): TreeNode | null {
    let queue = []
    if(root===null)return null
    queue.push(root)
    while(queue.length>0){
        for(let i=0,length=queue.length;i<length;i++){
            let cur = queue.shift(),
                tmp = cur.left
                cur.left = cur.right
                cur.right = tmp
                tmp = null

            if(cur.left!==null){
                queue.push(cur.left)
            }
            if(cur.right!==null){
                queue.push(cur.right)
            }
        }
    }
    return root
};
```

##### 方法二 递归

```ts
// 前序遍历
function invertTree(root: TreeNode | null): TreeNode | null {
    function reverse(cur){
        if(cur===null)return cur
        if(cur!==null)[cur.left,cur.right] = [cur.right,cur.left]
        reverse(cur.left)
        reverse(cur.right)
    }
    reverse(root)
    return root
};

// 后序遍历
function invertTree(root: TreeNode | null): TreeNode | null {
    function reverse(cur){
        if(cur===null)return cur
        reverse(cur.left)
        reverse(cur.right)
        if(cur!==null)[cur.left,cur.right] = [cur.right,cur.left]
    }
    reverse(root)
    return root
};

// 中序遍历
function invertTree(root: TreeNode | null): TreeNode | null {
    function reverse(cur){
        if(cur===null)return cur
        reverse(cur.left)
        if(cur!==null)[cur.left,cur.right] = [cur.right,cur.left]
        reverse(cur.left)  //要注意这边还是翻转left，中序遍历与前面两个不同的地方
    }
    reverse(root)
    return root
};
```

## 对称二叉树

题号[101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

### 思考

1. 要判断是否对称也就是能不能翻转
2. 因为要先比较下面的子节点一步一步往上退所以只能用后序

##### 方法一 后序递归

```ts
function isSymmetric(root: TreeNode | null): boolean {
    function compare(left,right){
        if(left===null&&right!==null)return false
        else if(left!==null&&right===null)return false
        else if(left===null&&right===null)return true
        else if(left.val!==right.val)return false
        else if(left!==null&&right!==null){
           let outside=  compare(left.left,right.right),
                inside = compare(left.right,right.left)
        return  outside&&inside
            
        }
    }
    return compare(root.left,root.right)

};
```

