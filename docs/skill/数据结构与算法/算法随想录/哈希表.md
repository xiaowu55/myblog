# 哈希表

## 什么时候使用哈希法

当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。

- 数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。
- set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。

## 有效的字母异位词

题号[242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)

### 思考

1. 这道题目可以使用数组和Map来做，核心在于使用哈希表来统计字母出现的次数
2. 写法上有个细节是要让字符串变为ASCII码使用在Object.charCodeAt这个方法
3. 数组就是简单的哈希表

##### 方法一 数组

```ts
function isAnagram(s: string, t: string): boolean {
    let r:number[] = new Array(26).fill(0)
    for(let i of s){
        r[i.charCodeAt(0)-'a'.charCodeAt(0)]++
    }
    for(let i of t){
        r[i.charCodeAt(0)-'a'.charCodeAt(0)]--
    }
    return r.every(item=>item===0)
};
```

##### 方法二 Map

```ts
function isAnagram(s: string, t: string): boolean {
  const len1 = s.length;
  const len2 = t.length;

  // 如果两个字符串长度不同，直接返回 false
  if (len1 !== len2) {
    return false;
  }

  const dic: Map<string, number> = new Map();

  // 统计字符串 s 中字符的出现次数
  for (let i = 0; i < len1; i++) {
    const char = s.charAt(i);
    dic.set(char, (dic.get(char) || 0) + 1);
  }

  // 在字符串 t 中减少字符的出现次数
  for (let i = 0; i < len2; i++) {
    const char = t.charAt(i);
    const count = dic.get(char);
    if (count === undefined || count === 0) {
      // 字符在 t 中出现次数大于在 s 中，或在 s 中没有出现过，直接返回 false
      return false;
    }
    dic.set(char, count - 1);
  }

  // 遍历字典，如果所有字符的出现次数都为 0，则返回 true，否则返回 false
  for (const count of dic.values()) {
    if (count !== 0) {
      return false;
    }
  }

  return true;
}

```

## 两个数组的交集

题号[349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)

### 思考

1. 思路和字母异位差不多都是计数
2. 如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费

##### 方法一 正常解法

```ts
function intersection(nums1: number[], nums2: number[]): number[] {
    let resSet: Set<number> = new Set(),
        nums1Set: Set<number> = new Set(nums1);
    for (let i of nums2) {
        if (nums1Set.has(i)) {
            resSet.add(i);
        }
    }
    return Array.from(resSet);
};
```

##### 方法二 骚操作

```ts
function intersection(nums1: number[], nums2: number[]): number[] {
    return Array.from(new Set(nums1.filter(i => nums2.includes(i))))
};
```

##### 方法三 Map

```ts
function intersection(nums1: number[], nums2: number[]): number[] {
    let r = new Map(),
        result = []
    for(let i of nums1){
        if(!r.get(i)){
            r.set(i,0)
        }else{
            r.set(i,r[i]++)
        }
    }
    for(let i of nums2){
        if(r.has(i)&&r.get(i)>=0){
            result.push(i)
            r.set(i,r[i]--)
        }
    }

    return result
};
```

## 快乐数

题号[202. 快乐数](https://leetcode.cn/problems/happy-number/)

### 思考

1. 首先要有思路怎么求快乐数，而且要有思路，当n开始循环的时候就应该返回false了，这时候要查询所以使用哈希表
2. 然后再考虑其他方法

##### 方法一 利用Map来搜索

```ts
function isHappy(n: number): boolean {
    let m = new Map()
    function getNum(n){
        let sum = 0
        while(n){
            sum+=(n%10)**2
            n = Math.floor(n/10)
        }
        return sum
    }
    
    while(true){
        if(m.has(n))return false
        if(n===1)return true
        m.set(n,1)
        n = getNum(n)
    }
};
```

## 