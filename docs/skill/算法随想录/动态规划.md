# 动态规划

## 斐波那契数

题号[509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/)

思考

1. 动态规划五部曲
	1. 确定dp数组及其下标的含义
	2. 确定递归公式
	3. dp数组如何初始化
	4. 确定遍历顺序
	5. 举例推到dp数组

##### 方法一   动态数组

```ts
function fib(n: number): number {
    let dp = []
    dp[0] = 0
    dp[1] = 1
    for(let i=2;i<=n;i++){
        dp[i] = dp[i-1]+dp[i-2]
    }
    return dp[n]
};
```

##### 优化动态数组

```ts
function fib(n: number): number {
 // 动规状态转移中，当前结果只依赖前两个元素的结果，所以只要两个变量代替dp数组记录状态过程。将空间复杂度降到O(1)
    let pre1 = 1
    let pre2 = 0
    let temp
    if (n === 0) return 0
    if (n === 1) return 1
    for(let i = 2; i <= n; i++) {
        temp = pre1
        pre1 = pre1 + pre2
        pre2 = temp
    }
    return pre1
};
```

##### 方法二 递归

```ts
function fib(n: number): number {
    if(n<2)return n
    return fib(n-1)+fib(n-2)
};
```

## 爬楼梯

题号[70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

思考

1. 没有给出状态转移方程，所以我们得学会自己推
2. 自己推之后发现其实就是斐波那契数列

##### 方法一 动态规划

```ts
function climbStairs(n: number): number {
    let dp = []
    dp[1] = 1
    dp[2] = 2
    for(let i=3;i<=n;i++){
        dp[i] = dp[i-1]+dp[i-2]
    }
    return dp[n]
};
```

## 使用最小花费爬楼梯

题号

思考

1. 确定dp数组和下标的含义

	1. 到达i位置所需的最小花费值

2. 确定递归公式

	1. **可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]**。

		dp[i - 1] 跳到 dp[i] 需要花费 dp[i - 1] + cost[i - 1]。

		dp[i - 2] 跳到 dp[i] 需要花费 dp[i - 2] + cost[i - 2]。

		取其中最小的

3. dp数组如何初始化

	1. 可以选择从位置0开始也可以选择从位置1开始所以

		dp[1]=0,dp[0]=0

4. 确定遍历顺序

	1. 模拟台阶，而且dp[i]由dp[i-1]dp[i-2]推出，所以是从前到后遍历cost数组就可以了

5. 距离推导dp数组

##### 方法一

```ts
function minCostClimbingStairs(cost: number[]): number {
    let dp = []
    dp[0] = 0
    dp[1] = 0
    for(let i=2;i<=cost.length;i++){
        dp[i] = Math.min(cost[i-1]+dp[i-1],cost[i-2]+dp[i-2])
    }
    return dp[cost.length]
};
```

