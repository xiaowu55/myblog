# 贪心算法

## 分发饼干

题号[455. 分发饼干](https://leetcode.cn/problems/assign-cookies/)

### 思考

1. 先用大饼干满足胃口大的小孩

##### 方法一

```ts
function findContentChildren(g: number[], s: number[]): number {
    g = g.sort((a, b) => a - b);
    s = s.sort((a, b) => a - b);
    let result = 0;
    let index = s.length - 1;
    for (let i = g.length - 1; i >= 0; i--) {
        if (index >= 0 && s[index] >= g[i]) {
            result++;
            index--;
        }
    }
    return result;
};
```

## 摆动序列

题号[376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)

### 思考

##### 方法一

```ts
function wiggleMaxLength(nums: number[]): number {
  let length: number = nums.length;
  if (length <= 1) return length;
  let preDiff: number = 0;
  let curDiff: number = 0;
  let count: number = 1;
  for (let i = 1; i < length; i++) {
    curDiff = nums[i] - nums[i - 1];
    if ((preDiff <= 0 && curDiff > 0) || (preDiff >= 0 && curDiff < 0)) {
      preDiff = curDiff;
      count++;
    } 
  }
  return count;
}
```

## 最大子数组和

题号[53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

### 思考

1. 如果是负数就会带来负担，重启就可以了
2. 记录最大值

##### 方法一

```ts
function maxSubArray(nums: number[]): number {
  let curSum: number = 0;
  let resMax: number = -Infinity;
  for (let i = 0; i < nums.length; i++) {
    curSum += nums[i];
    resMax = Math.max(curSum, resMax);
    if (curSum < 0) curSum = 0;
  }
  return resMax;
}
```

## 买卖股票的最佳时机 II

题号[122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

### 思考

1. 算出每天的利率，只挑选获利的就简化为上一题了

##### 方法一

```ts
function maxProfit(prices: number[]): number {
    let result = 0
    for(let i=1;i<prices.length;i++){
        result += Math.max(prices[i]-prices[i-1],0)
    }
    return result
};
```

## 跳跃游戏

题号[55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)

### 思考

1. 每次都去最大的覆盖范围

##### 方法一

```ts
function canJump(nums: number[]): boolean {
    if (nums.length === 1) return true
    let cover = 0
    for (let i = 0; i <= cover; i++) {
        cover = Math.max(cover, i + nums[i])
        if (cover >= nums.length - 1) {
            return true
        }
    }
    return false
};
```

## 跳跃游戏 II

题号[45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)

### 思考

1. 要考虑下一步

##### 方法一

```ts
function jump(nums: number[]): number {
  const length: number = nums.length;
  let curFarthestIndex: number = 0,
    nextFarthestIndex: number = 0;
  let curIndex: number = 0;
  let stepNum: number = 0;
  while (curIndex < length - 1) {
    nextFarthestIndex = Math.max(nextFarthestIndex, curIndex + nums[curIndex]);
    if (curIndex === curFarthestIndex) {
      curFarthestIndex = nextFarthestIndex;
      stepNum++;
    }
    curIndex++;
  }
  return stepNum;
}
```

## K 次取反后最大化的数组和

题号[1005. K 次取反后最大化的数组和](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/)

### 思考

1. 按绝对值排序
2. 如果还有k，先把负数变为正的
3. 如果有多余的k，就反复翻转绝对值最小的元素

##### 方法一

```ts
function largestSumAfterKNegations(nums: number[], k: number): number {
    nums.sort((a,b) => Math.abs(b) - Math.abs(a))
    for(let i = 0 ;i < nums.length; i++){
        if(nums[i] < 0 && k > 0){
            nums[i] = - nums[i];
            k--;
        }
    }
    // 若k还大于0,则寻找最小的数进行不断取反
    while( k > 0 ){
        nums[nums.length-1] = - nums[nums.length-1]
        k--;
    }
    // 使用箭头函数的隐式返回值时，需使用简写省略花括号，否则要在 a + b 前加上 return
    return nums.reduce((a, b) => a + b)
};
```

## 加油站

题号[134. 加油站](https://leetcode.cn/problems/gas-station/)

### 思考

1. 使用暴力法，遍历存在的所有可能
2. 贪心算法

##### 方法一 暴力法

```ts
// 暴力法

function canCompleteCircuit(gas: number[], cost: number[]): number {
    for(let i=0;i<cost.length;i++){
        let rest = gas[i]-cost[i] //记录剩余油量
        // 以i为起点行驶一圈，index为下一个目的地
        let index = (i+1)%cost.length
        while(rest>0&& index!==i){
            rest+=gas[index] - cost[index]
            index = (index+1)%cost.length
        }
        if(rest>=0&&index===i)return i
    }
    return -1
};
```

##### 方法二 贪心算法

```ts
function canCompleteCircuit(gas: number[], cost: number[]): number {
    let total: number = 0;    // 记录总的剩余油量
    let curGas: number = 0;   // 记录当前剩余油量
    let tempDiff: number = 0; // 记录当前加油站的油量和花费之差
    let resIndex: number = 0; // 记录起始加油站的索引
    for (let i = 0, length = gas.length; i < length; i++) {
        tempDiff = gas[i] - cost[i];
        total += tempDiff;    // 累计总的剩余油量
        curGas += tempDiff;   // 更新当前剩余油量
        if (curGas < 0) {
            resIndex = i + 1;  // 如果当前剩余油量为负数，将下一个加油站作为新的起始站
            curGas = 0;        // 重置当前剩余油量
        }
    }
    if (total < 0) return -1; // 如果总的剩余油量小于0，无法环绕一圈，返回-1
    return resIndex; // 返回起始加油站的索引
};

```

## 分发糖果

题号[135. 分发糖果](https://leetcode.cn/problems/candy/)

### 思考

1. 两次贪心来做

	1. 先保证右边高分孩子一定比左边低分孩子发更多的糖果
	2. 再保证左边高分孩子一定比右边低分孩子发更多的糖果

	##### 方法一 贪心算法

	```ts
	function candy(ratings: number[]): number {
	    const candies: number[] = [];
	    candies[0] = 1;
	    // 保证右边高分孩子一定比左边低分孩子发更多的糖果
	    for (let i = 1, length = ratings.length; i < length; i++) {
	        if (ratings[i] > ratings[i - 1]) {
	            candies[i] = candies[i - 1] + 1;
	        } else {
	            candies[i] = 1;
	        }
	    }
	    // 保证左边高分孩子一定比右边低分孩子发更多的糖果
	    for (let i = ratings.length - 2; i >= 0; i--) {
	        if (ratings[i] > ratings[i + 1]) {
	            candies[i] = Math.max(candies[i], candies[i + 1] + 1);
	        }
	    }
	    return candies.reduce((pre, cur) => pre + cur);
	};
	```

	

## 柠檬水找零

题号[860. 柠檬水找零](https://leetcode.cn/problems/lemonade-change/)

### 思考

1. 抽象成三种情况
	1. 收到5元就把5元的张数加1
	2. 收到10元就把10元加一5元减一
	3. 收到20元的有两种情况
		1. 5元和10元的各减一
		2. 5元的减三
2. 如果不满足就返回false

##### 方法一

```ts
function lemonadeChange(bills: number[]): boolean {
    let fiveCount = 0,
        tenCount = 0

    for (let i = 0; i < bills.length; i++) {
        let bill = bills[i]
        if (bill === 5) {
            fiveCount++
        } else if (bill === 10) {
            if (fiveCount > 0) {
                fiveCount--
                tenCount++
            } else {
                return false
            }
        }else {
            if(tenCount>0&&fiveCount>0){
                tenCount--
                fiveCount--
            }else if(fiveCount>=3){
                fiveCount-=3
            }else{
                return false
            }
        }
    }
    return true
};
```

